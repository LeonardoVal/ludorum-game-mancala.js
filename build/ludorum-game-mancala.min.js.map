{"version":3,"sources":["../src/__prologue__.js","../src/Mancala.js","../src/__epilogue__.js","../src/heuristics.js"],"names":["__init__","base","Sermat","ludorum","declare","raiseIf","raise","Iterable","iterable","Game","exports","players","UserInterface","__package__","__name__","__dependencies__","__SERMAT__","include","Mancala","name","constructor","activePlayer","board","call","this","makeBoard","dual makeBoard","seeds","houses","isNaN","result","j","i","push","emptyCapture","countRemainingSeeds","store","player","indexOf","length","Error","range","toArray","oppositeHouse","playerHouses","opponentHouses","opponent","index","reverse","nextSquare","moves","filter","house","scores","game","sides","map","h","sum","_scores","forEach","zerosumResult","next","haps","update","freeTurn","move","newBoard","slice","nextPlayer","activatePlayers","resultBounds","stoneCount","static __SERMAT__","identifier","serializer","obj","charAt","n","toString","substr","join","printBoard","lpad","Text","north","northHouses","northStore","south","southHouses","southStore","repeat","games","heuristics","fromWeights","weights","weightSum","Math","abs","__heuristic__","signum","seedSum","DEFAULT"],"mappings":"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","file":"ludorum-game-mancala.min.js","sourcesContent":["/** Package wrapper and layout.\n*/\nfunction __init__(base, Sermat, ludorum) { \"use strict\";\n// Import synonyms. ////////////////////////////////////////////////////////////////////////////////\n\tvar declare = base.declare,\n\t\t//obj = base.obj,\n\t\t//copy = base.copy,\n\t\traise = base.raise,\n\t\traiseIf = base.raiseIf,\n\t\tIterable = base.Iterable,\n\t\titerable = base.iterable,\n\t\tGame = ludorum.Game,\n\t\tUserInterface = ludorum.players.UserInterface;\n\n// Library layout. /////////////////////////////////////////////////////////////////////////////////\n\tvar exports = {\n\t\t__package__: 'ludorum-game-mancala',\n\t\t__name__: 'ludorum_game_mancala',\n\t\t__init__: __init__,\n\t\t__dependencies__: [base, Sermat, ludorum],\n\t\t__SERMAT__: { include: [base, ludorum] }\n\t};\n","/** # Mancala\n\nImplementation of the [Kalah](http://en.wikipedia.org/wiki/Kalah) member of the\n[Mancala family of games](http://en.wikipedia.org/wiki/Mancala).\n*/\nvar Mancala = exports.Mancala = declare(Game, {\n\tname: 'Mancala',\n\n\t/** The constructor takes the `activePlayer` (`\"North\"` by default) and the board as an array of\n\tintegers (initial board by default).\n\t*/\n\tconstructor: function Mancala(activePlayer, board){\n\t\tGame.call(this, activePlayer);\n\t\tthis.board = board || this.makeBoard();\n\t},\n\n\t/** `makeBoard(seeds, houses)` builds an array for the given amounts of houses and seeds per\n\thouse. By default 4 seeds and 6 houses per player are assumed.\n\t*/\n\t'dual makeBoard': function makeBoard(seeds, houses){\n\t\tseeds = isNaN(seeds) ? 4 : +seeds;\n\t\thouses = isNaN(houses) ? 6 : +houses;\n\t\tvar result = [];\n\t\tfor(var j = 0; j < 2; j++){\n\t\t\tfor(var i = 0; i < houses; i++){\n\t\t\t\tresult.push(seeds);\n\t\t\t}\n\t\t\tresult.push(0);\n\t\t}\n\t\treturn result;\n\t},\n\n\t/** The players' roles in a Mancala match are `\"North\"` and `\"South\"`.\n\t*/\n\tplayers: [\"North\", \"South\"],\n\n\t/** If `emptyCapture` is true, making a capture only moves the active player's seed to his\n\tstore, and the opponents seeds are not captured. By default this is false.\n\t*/\n\temptyCapture: false,\n\n\t/** If `countRemainingSeeds` is true, at the end of the game if a player has seeds on his\n\thouses, those seeds are included in his score. This is the default behaviour.\n\t*/\n\tcountRemainingSeeds: true,\n\n\t// ## Game state information ###################################################################\n\n\t/** `store(player)` returns the index in this game's board of the player's store.\n\t*/\n\tstore: function store(player){\n\t\tswitch (this.players.indexOf(player)) {\n\t\t\tcase 0: return this.board.length / 2 - 1; // Store of North.\n\t\t\tcase 1: return this.board.length - 1; // Store of South.\n\t\t\tdefault: throw new Error(\"Invalid player \"+ player +\".\");\n\t\t}\n\t},\n\n\t/** `houses(player)` returns an array with the indexes of the player's houses in this game's\n\tboard.\n\t*/\n\thouses: function houses(player){\n\t\tswitch (this.players.indexOf(player)) {\n\t\t\tcase 0: return Iterable.range(0, this.board.length / 2 - 1).toArray(); // Store of North.\n\t\t\tcase 1: return Iterable.range(this.board.length / 2, this.board.length - 1).toArray(); // Store of South.\n\t\t\tdefault: throw new Error(\"Invalid player \"+ player +\".\");\n\t\t}\n\t},\n\n\t/** The house in front of a players house is calculated by `oppositeHouse(player, i)`. It\n\treturns the index of the opposite house of `i` for the given player, or a negative if `i` is not\n\ta house of the given player. This is necessary for resolving captures.\n\t*/\n\toppositeHouse: function oppositeHouse(player, i) {\n\t\tvar playerHouses = this.houses(player),\n\t\t\topponentHouses = this.houses(this.opponent(player)),\n\t\t\tindex = playerHouses.indexOf(i);\n\t\treturn index < 0 ? index : opponentHouses.reverse()[index];\n\t},\n\n\t/** The flow of seeds on the board is defined by `nextSquare(player, i)`. It returns the index\n\tof the square following `i` for the given player.\n\t*/\n\tnextSquare: function nextSquare(player, i){\n\t\tdo {\n\t\t\ti = (i + 1) % this.board.length;\n\t\t} while (i === this.store(this.opponent(player)));\n\t\treturn i;\n\t},\n\n\t// ## Game logic ###############################################################################\n\n\t/** A move for a Mancala player is an index of the square in the board.\n\t*/\n\tmoves: function moves(){\n\t\tif (this.result()) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\tvar board = this.board,\n\t\t\t\tresult = {},\n\t\t\t\tactivePlayer = this.activePlayer();\n\t\t\tresult[activePlayer] = this.houses(activePlayer).filter(function(house){\n\t\t\t\treturn board[house] > 0; // The house has seeds.\n\t\t\t});\n\t\t\treturn result[activePlayer].length > 0 ? result : null;\n\t\t}\n\t},\n\n\t/** The game ends when the active player cannot move. The `score()` for each player is the seed\n\tcount of its store and (if `countRemainingSeeds` is true) the houses on its side of the board.\n\t*/\n\tscores: function scores() {\n\t\tvar game = this,\n\t\t\tboard = this.board,\n\t\t\tsides = this.players.map(function (player) {\n\t\t\t\treturn iterable(game.houses(player)).map(function (h) {\n\t\t\t\t\treturn board[h];\n\t\t\t\t}).sum();\n\t\t\t});\n\t\tif (sides[0] > 0 && sides[1] > 0) { // Both sides have seeds.\n\t\t\treturn null;\n\t\t} else { // One side has no seeds.\n\t\t\tvar _scores = {};\n\t\t\tthis.players.forEach(function (player, i) {\n\t\t\t\t_scores[player] = board[game.store(player)] + game.countRemainingSeeds * sides[i];\n\t\t\t});\n\t\t\treturn _scores;\n\t\t}\n\t},\n\n\t/** The result for each player is the difference between its score and the opponent's.\n\t*/\n\tresult: function result() {\n\t\tvar scores = this.scores(),\n\t\t\tplayers = this.players;\n\t\treturn scores && this.zerosumResult(scores[players[0]] - scores[players[1]], players[0]);\n\t},\n\n\t/** The `next(moves)` game state implies taking all seeds from the selected house and moving\n\tthem across the board, placing one seed at each step. A player can pass through its store but\n\tnot through the opponent's. If the move ends at the active player's store, then it has another\n\tmove. If it ends at an empty house, capture may occur.\n\t*/\n\tnext: function next(moves, haps, update) {\n\t\traiseIf(haps, 'Haps are not required (given ', haps, ')!');\n\t\tvar activePlayer = this.activePlayer(),\n\t\t\tmove = +moves[activePlayer],\n\t\t\tnewBoard = this.board.slice(0),\n\t\t\tseeds = newBoard[move],\n\t\t\tfreeTurn = false,\n\t\t\tstore, oppositeHouse;\n\t\traiseIf(seeds < 1, \"Invalid move \", move, \" for game \", this);\n\t\t// Move.\n\t\tnewBoard[move] = 0;\n\t\tfor (; seeds > 0; seeds--) {\n\t\t\tmove = this.nextSquare(activePlayer, move);\n\t\t\tnewBoard[move]++;\n\t\t}\n\t\t// Free turn if last square of the move is the player's store.\n\t\tfreeTurn = move == this.store(activePlayer);\n\t\t// Capture.\n\t\tif (!freeTurn) {\n\t\t\toppositeHouse = this.oppositeHouse(activePlayer, move);\n\t\t\tif (oppositeHouse >= 0 && newBoard[move] == 1 && newBoard[oppositeHouse] > 0) {\n\t\t\t\tstore = this.store(activePlayer);\n\t\t\t\tnewBoard[store]++;\n\t\t\t\tnewBoard[move] = 0;\n\t\t\t\tif (!this.emptyCapture) {\n\t\t\t\t\tnewBoard[store] += newBoard[oppositeHouse];\n\t\t\t\t\tnewBoard[oppositeHouse] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvar nextPlayer = freeTurn ? activePlayer : this.opponent();\n\t\tif (update) {\n\t\t\tthis.activatePlayers(nextPlayer);\n\t\t\tthis.board = newBoard;\n\t\t\treturn this;\n\t\t} else {\n\t\t\treturn new this.constructor(nextPlayer, newBoard);\n\t\t}\n\t},\n\n\t/** The `resultBounds` for a Mancala game are estimated with the total number of seeds in the\n\tboard. It is very unlikely to get these result though.\n\t*/\n\tresultBounds: function resultBounds() {\n\t\tvar stoneCount = iterable(this.board).sum();\n\t\treturn [-stoneCount,+stoneCount];\n\t},\n\n\t// ## Utility methods ##########################################################################\n\n\t/** Serialization is used in the `toString()` method, but it is also vital for sending the game\n\tstate across a network or the marshalling between the rendering thread and a webworker.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: exports.__package__ +'.Mancala',\n\t\tserializer: function serialize_Mancala(obj) {\n\t\t\treturn [obj.activePlayer(), obj.board];\n\t\t}\n\t},\n\n\tidentifier: function identifier() {\n\t\treturn this.activePlayer().charAt(0) + this.board.map(function (n) {\n\t\t\treturn ('00'+ n.toString(36)).substr(-2);\n\t\t}).join('');\n\t},\n\n\t/** `printBoard()` creates a text (ASCII) version of the board.\n\t*/\n\tprintBoard: function printBoard() {\n\t\tvar game = this,\n\t\t\tlpad = base.Text.lpad,\n\t\t\tnorth = this.players[0],\n\t\t\tnorthHouses = this.houses(north).map(function (h) {\n\t\t\t\treturn lpad(''+ game.board[h], 2, '0');\n\t\t\t}).reverse(),\n\t\t\tnorthStore = lpad(''+ this.board[this.store(north)], 2, '0'),\n\t\t\tsouth = this.players[1],\n\t\t\tsouthHouses = this.houses(south).map(function (h) {\n\t\t\t\treturn lpad(''+ game.board[h], 2, '0');\n\t\t\t}),\n\t\t\tsouthStore = lpad(''+ this.board[this.store(south)], 2, '0');\n\t\treturn \"   \"+ northHouses.join(\" | \") +\"   \\n\"+\n\t\t\tnorthStore +\" \".repeat(northHouses.length * 2 + (northHouses.length - 1) * 3 + 2) + southStore +\"\\n\"+\n\t\t\t\"   \"+ southHouses.join(\" | \") +\"   \";\n\t}\n}); // declare Mancala.\n\n// ## Mancala type initialization ##################################################################\n\n/** Adding Mancala to `ludorum.games`.\n*/\nludorum.games.Mancala = Mancala;\n\n/** Sermat serialization.\n*/\nexports.__SERMAT__.include.push(Mancala);\nSermat.include(exports);\n","// See __prologue__.js\n\treturn exports;\n}\n","/** # Heuristics for Mancala\n\n`Mancala.heuristics` is a bundle of helper functions to build heuristic evaluation functions for\nthis game.\n*/\nMancala.heuristics = {\n\t/** + `heuristicFromWeights(weights=default weights)` builds an heuristic evaluation\n\t\tfunction from weights for each square in the board. The result of the function is the\n\t\tnormalized weighted sum.\n\t*/\n\tfromWeights: function fromWeights(weights) {\n\t\tvar weightSum = iterable(weights).map(Math.abs).sum();\n\t\tfunction __heuristic__(game, player) {\n\t\t\tvar seedSum = 0, signum, result;\n\t\t\tswitch (game.players.indexOf(player)) {\n\t\t\t\tcase 0: signum = 1; break; // North.\n\t\t\t\tcase 1: signum = -1; break; // South.\n\t\t\t\tdefault: throw new Error(\"Invalid player \"+ player +\".\");\n\t\t\t}\n\t\t\tresult = iterable(game.board).map(function (seeds, i) {\n\t\t\t\tseedSum += seeds;\n\t\t\t\treturn seeds * weights[i]; //TODO Normalize weights before.\n\t\t\t}).sum() / weightSum / seedSum * signum;\n\t\t\treturn result;\n\t\t}\n\t\t__heuristic__.weights = weights;\n\t\treturn __heuristic__;\n\t}\n};\n\n/** The `DEFAULT` heuristic for Mancala is based on weights for each square. Stores are worth 5 and\nhouses 1, own possitive and the opponent's negative.\n*/\nMancala.heuristics.DEFAULT = Mancala.heuristics.fromWeights(\n\t[+1,+1,+1,+1,+1,+1,+5, /**/ -1,-1,-1,-1,-1,-1,-5]\n);\n"]}